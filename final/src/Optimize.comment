我来逐行详细解释 `findStats` 函数的实现：

```c
void findStats(uint64_t *column, struct columnStats *stat, unsigned columnSize)
{
```

**函数声明**：接受一个数据列指针、统计信息结构体指针和列大小。

```c
    /* Find MIN and MAX */
    uint64_t min = column[0];
    uint64_t max = column[0];
```

**初始化**：将第一个元素同时设为最小值和最大值的初始值。

```c
    for (unsigned i = 1; i < columnSize; ++i)
    {
```

**遍历循环**：从第二个元素开始遍历整个列。

```c
        if (column[i] > max)
            max = column[i];
```

**更新最大值**：如果当前元素大于当前最大值，更新最大值。

```c
        if (column[i] < min)
            min = column[i];
```

**更新最小值**：如果当前元素小于当前最小值，更新最小值。

```c
    }
```

**结束最小值最大值查找循环**。

```c
    /* Find discrete values */
    unsigned nbits  = (max - min + 1 > PRIMELIMIT) ? PRIMELIMIT : max - min + 1;
```

**计算位向量大小**：
- `max - min + 1`：数据范围的大小
- 如果范围大于 `PRIMELIMIT`（49,999,991），使用 `PRIMELIMIT`
- 否则使用实际范围大小

```c
    stat->bitVector = calloc(BITNSLOTS(nbits), CHAR_BIT);
```

**分配位向量内存**：
- `BITNSLOTS(nbits)`：计算需要的字节数（⌈nbits/8⌉）
- `calloc`：分配并清零内存，所有位初始为0
- `CHAR_BIT`：通常是8（一个字节的位数）

```c
    MALLOC_CHECK(stat->bitVector);
```

**内存分配检查**：确保内存分配成功（应该是自定义的宏）。

```c
    stat->discreteValues = 0;
```

**初始化离散值计数器**：从0开始计数。

```c
    /* Find the way to fill the boolean array depending on its size relative to PRIMELIMIT */
    if (nbits != PRIMELIMIT)
    {
```

**情况1：直接映射**：当数据范围不大时（≤ PRIMELIMIT）。

```c
        stat->typeOfBitVector = 0;
```

**设置位向量类型**：0表示直接映射。

```c
        for (unsigned i = 0; i < columnSize; ++i)
        {
```

**遍历所有数据元素**。

```c
            if(BITTEST(stat->bitVector,column[i]-min) == 0)
                (stat->discreteValues)++;
```

**检查并计数离散值**：
- `BITTEST`：检查位是否已设置
- 如果位为0，说明这个值是第一次出现，增加离散值计数

```c
            BITSET(stat->bitVector,column[i]-min);
```

**设置位**：标记这个值已经出现过。
- `column[i]-min`：将值映射到0-based索引

```c
        }
```

**结束直接映射的循环**。

```c
    }
    else
    {
```

**情况2：哈希映射**：当数据范围很大时（> PRIMELIMIT）。

```c
        stat->typeOfBitVector = 1;
```

**设置位向量类型**：1表示哈希映射。

```c
        for (unsigned i = 0; i < columnSize; ++i)
        {
```

**遍历所有数据元素**。

```c
            if(BITTEST(stat->bitVector,(column[i]-min) % PRIMELIMIT) == 0)
                (stat->discreteValues)++;
```

**检查并计数离散值（哈希版本）**：
- `(column[i]-min) % PRIMELIMIT`：使用模运算进行哈希映射
- 检查哈希后的位是否已设置

```c
            BITSET(stat->bitVector,(column[i]-min) % PRIMELIMIT);
```

**设置位（哈希版本）**：标记这个哈希值已经出现过。

```c
        }
```

**结束哈希映射的循环**。

```c
    }
```

**结束位向量填充的if-else块**。

```c
    /* Assign the remaining values to the stats*/
    stat->minValue      = min;
```

**设置最小值**。

```c
    stat->maxValue      = max;
```

**设置最大值**。

```c
    stat->f             = columnSize;
```

**设置频率**：列中的元素总数。

```c
    stat->bitVectorSize = nbits;
```

**设置位向量大小**：实际使用的位数量。

```c
}
```

**函数结束**。

## 关键技术点详解

### 位操作宏的工作方式：

```c
#define BITMASK(b) (1 << ((b) % CHAR_BIT))
// 示例：b=10, CHAR_BIT=8 → 1 << (10%8=2) → 1<<2 = 4 (00000100)

#define BITSLOT(b) ((b) / CHAR_BIT)  
// 示例：b=10, CHAR_BIT=8 → 10/8=1 (第二个字节)

#define BITSET(v,b) ((v)[BITSLOT(b)] |= BITMASK(b))
// 设置第b位：v[1] |= 4

#define BITTEST(v,b) ((v)[BITSLOT(b)] & BITMASK(b))
// 测试第b位：v[1] & 4
```

### 内存使用示例：

如果 `nbits = 1000`：
- `BITNSLOTS(1000) = ⌈1000/8⌉ = 125` 字节
- 只需要125字节就能跟踪1000个不同的值

### 哈希冲突处理：

当使用哈希映射时，不同的原始值可能映射到同一位：
- 值1000和值1000+PRIMELIMIT都会映射到同一位
- 这会导致离散值计数偏小（保守估计）
- 但由于PRIMELIMIT很大（49M），冲突概率很低

这个函数完美体现了数据库系统中**空间-时间权衡**的设计哲学，用适度的内存开销换取了高效的统计信息收集能力。

********************************************88

我来逐行详细解释这个重要的统计信息更新函数：

```c
void applyColEqualityEstimations(struct QueryInfo *q, struct Joiner *j)
{
```

**函数声明**：处理同一关系内的列相等条件统计估算。

```c
    for(unsigned i = 0 ; i < q->numOfPredicates; ++i)
    {
```

**遍历所有谓词**：检查每个查询条件。

```c
        unsigned leftRelId        = getRelId(&q->predicates[i].left);
        unsigned rightRelId       = getRelId(&q->predicates[i].right);
        unsigned leftColId        = getColId(&q->predicates[i].left);
        unsigned rightColId       = getColId(&q->predicates[i].right);
```

**提取谓词信息**：
- 左右关系ID和列ID
- 例如：对于 `employees.salary = employees.bonus`

```c
        unsigned actualId         = getOriginalRelId(q, &q->predicates[i].left);
```

**获取实际关系ID**：处理关系别名的情况。

```c
        struct columnStats *stat1 = &q->estimations[leftRelId][leftColId];
        struct columnStats *stat2 = &q->estimations[rightRelId][rightColId];
```

**获取统计信息**：左右列的统计信息指针。

```c
        struct columnStats *temp;
```

**临时指针**：用于更新其他列的统计信息。

```c
        // Same relation - different columns
        if(isColEquality(&q->predicates[i]) && (leftColId != rightColId))
        {
```

**情况1：同一关系内不同列的相等比较**（如：salary = bonus）

```c
            // Find estimations for the two columns
            uint64_t newMin;
            uint64_t newMax;
            unsigned newF;
            unsigned newD;
```

**定义新统计值**：最小值、最大值、频率、离散值数量。

```c
            newMin = (stat1->minValue > stat2->minValue) ? stat1->minValue : stat2->minValue;
```

**计算新最小值**：取两个列最小值的较大者（交集的下界）。

```c
            newMax = (stat1->maxValue < stat2->maxValue) ? stat1->maxValue : stat2->maxValue;
```

**计算新最大值**：取两个列最大值的较小者（交集的上界）。

```c
            newF   = stat1->f / (newMax - newMin + 1);
```

**计算新频率**：基于选择率的估算。
- 公式：新频率 = 原频率 / 值域范围
- 假设值均匀分布

```c
            newD   = stat1->discreteValues * (1-power(1-(newF/stat1->f),stat1->f/stat1->discreteValues));
```

**计算新离散值数量**：使用概率公式估算。
- 基于二项分布的概率模型
- 估算连接后剩余的离散值数量

```c
            /* Update the statistics of every other column except for the ones taking part in the equality  */
            for (unsigned c = 0; c < (*(j->relations[actualId])).numOfCols; ++c)
            {
```

**更新其他列的统计信息**：遍历关系的所有列。

```c
                temp = &q->estimations[leftRelId][c];
                if ((c!=leftColId)  && (c!=rightColId))
                {
```

**跳过参与相等的列**：只更新其他列。

```c
                    /* In case stat1->f or temp->discreteValues is zero */
                    stat1->f = (stat1->f == 0) ? 1 : stat1->f;
                    temp->discreteValues = (temp->discreteValues == 0) ? 1 : temp->discreteValues;
```

**防止除零错误**：确保分母不为零。

```c
                    temp->discreteValues = temp->discreteValues * (1-power(1-(newF/stat1->f),temp->f/temp->discreteValues));
```

**更新其他列的离散值数量**：使用概率公式。
- 基于连接选择率调整其他列的统计信息
- 反映连接操作对数据分布的影响

```c
                }
            }
```

```c
            /* Update the statistics for the two columns taking part in the equality */
            stat1->minValue       = stat2->minValue       = newMin;
            stat1->maxValue       = stat2->maxValue       = newMax;
            stat1->f              = stat2->f              = newF;
            stat1->discreteValues = stat2->discreteValues = newD;
```

**更新参与列的统计信息**：设置新的最小值、最大值、频率和离散值数量。

```c
        }
        // Same relation - same column
        else if(isColEquality(&q->predicates[i]))
        {
```

**情况2：同一关系内同一列的相等比较**（自连接条件）

```c
            stat1->f = (stat1->f * stat1->f) / (stat1->maxValue - stat1->minValue + 1);
```

**计算新频率**：自连接的结果集大小估算。
- 公式：结果数 = (N²) / D （其中N是元组数，D是值域范围）
- 基于均匀分布假设

```c
            for (unsigned c = 0; c < (*(j->relations[actualId])).numOfCols; ++c)
            {
                temp = &q->estimations[leftRelId][c];
                if (c!=rightColId)
                    temp->f = stat1->f;
            }
```

**更新其他列的频率**：所有其他列的频率与参与列相同。
- 因为自连接后所有列的元组数都相同

```c
        }
    }
}
```

## 关键技术原理

### 1. **统计信息传播**
当两个列相等时，它们的统计信息会相互影响，需要同步更新。

### 2. **选择率估算公式**
- **不同列相等**：基于值域交集和概率模型
- **同一列相等**：基于自连接的数学公式

### 3. **相关性处理**
更新其他列的统计信息，反映连接操作对整体数据分布的影响。

### 4. **错误处理**
防止除零错误，确保估算公式的稳定性。

## 实际示例

### 示例1：不同列相等
```sql
-- employees.salary = employees.bonus
-- stat1: salary统计 (min=1000, max=10000, f=1000, D=100)
-- stat2: bonus统计 (min=500, max=8000, f=1000, D=80)

-- 计算结果：
-- newMin = max(1000,500) = 1000
-- newMax = min(10000,8000) = 8000  
-- newF = 1000 / (8000-1000+1) ≈ 0.143
-- newD ≈ 100 * (概率公式计算结果)
```

### 示例2：同一列相等
```sql
-- employees.id = employees.id (自连接)
-- stat1: id统计 (min=1, max=1000, f=1000, D=1000)

-- 计算结果：
-- newF = (1000 * 1000) / (1000-1+1) = 1000
```

这个函数体现了数据库优化器中复杂的统计信息维护机制，确保在执行计划生成时拥有准确的代价估算基础。
********************************************************
